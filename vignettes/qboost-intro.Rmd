---
title: "qboost: Quantile Gradient Boosting"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{qboost-intro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 4.5
)
```

## Overview

`qboost` wraps LightGBM quantile regression in a simple, tidy API. It offers
cross-validation, automatic best-iteration selection, calibrated diagnostics,
and publication-ready plots.

## Fit a model

```{r}
library(qboost)
set.seed(1)

n <- 200
x <- data.frame(
  x1 = rnorm(n),
  x2 = runif(n)
)
y <- 0.5 * x$x1 - 0.2 * x$x2 + rnorm(n, sd = 0.8)

fit <- qboost(
  x = x,
  y = y,
  tau = 0.3,
  nrounds = 200,
  nfolds = 5,
  early_stopping_rounds = 20
)
```

## Predict new values

```{r}
newdata <- head(x, 5)
predict(fit, newdata)
```

## Diagnostics and plots

```{r, fig.width=7, fig.height=4}
plots <- plot(fit, plot = FALSE)
plots$pinball
```

```{r, fig.width=7, fig.height=4}
plots$calibration
```

## Summary and calibration

```{r}
summary(fit)
```

`coverage` is the fraction of responses below the predicted quantile boundary;
`QCE` is its absolute deviation from the target `tau`. Pseudo-RÂ² compares model
pinball loss to a constant-quantile baseline.

## Feature importance

```{r}
importance.qboost(fit)
```

Use the `gain` column to interpret which variables contribute most to the fitted
quantile surface.
