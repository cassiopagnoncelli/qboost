---
title: "qboost: Quantile Gradient Boosting"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{qboost-intro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 4.5
)
```

## Overview

`qboost` wraps LightGBM quantile regression in a simple, tidy API. It offers
cross-validation, automatic best-iteration selection, calibrated diagnostics,
and publication-ready plots.

You can supply data via a formula (shown below) or by passing an `x`/`y` pair;
`qboost()` will derive the design matrix accordingly.

## Fit a model

```{r}
library(qboost)
set.seed(1)

n <- 200
df <- data.frame(
  x1 = rnorm(n),
  x2 = runif(n)
)
df$y <- 0.5 * df$x1 - 0.2 * df$x2 + rnorm(n, sd = 0.8)

fit <- qboost(
  y ~ x1 + x2,
  data = df,
  tau = 0.3,
  nrounds = 200,
  nfolds = 5,
  early_stopping_rounds = 20
)
```

## Predict new values

```{r}
newdata <- head(df[, c("x1", "x2")], 5)
predict(fit, newdata)
```

## Diagnostics and plots

```{r, fig.width=7, fig.height=4}
plots <- plot(fit, plot = FALSE)
plots$pinball
```

```{r, fig.width=7, fig.height=4}
plots$calibration
```

## Summary and calibration

```{r}
summary(fit)
```

`coverage` is the fraction of responses below the predicted quantile boundary;
`QCE` is its absolute deviation from the target `tau`. Pseudo-RÂ² compares model
pinball loss to a constant-quantile baseline.

## Feature importance

```{r}
importance.qboost(fit)
```

Use the `gain` column to interpret which variables contribute most to the fitted
quantile surface.
