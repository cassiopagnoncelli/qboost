#' Predict quantiles from a symbol-based mqbm model
#'
#' Routes predictions to the appropriate symbol-specific \code{\link{qbm}} model
#' based on the symbol identifier for each observation. Each prediction is generated
#' by the corresponding symbol's quantile regression model.
#'
#' @param object A fitted mqbm model object returned by \code{\link{mqbm}}.
#' @param newdata A data.frame or matrix of predictor variables. Must either
#'   contain a \code{symbol} column identifying which model to use for each
#'   observation, or \code{symbol} must be provided as a separate argument.
#' @param symbol Optional character vector specifying which symbol-specific model
#'   to use for each row of \code{newdata}. If \code{NULL} (default), the
#'   function looks for a \code{symbol} column in \code{newdata}. Must contain
#'   only symbols that were present in the training data.
#' @param ... Additional arguments (currently unused).
#'
#' @return A numeric vector of length \code{nrow(newdata)} containing predicted
#'   quantile values. Each prediction is generated by the symbol-specific model
#'   corresponding to that observation's symbol identifier.
#'
#' @details
#' The prediction process:
#' \enumerate{
#'   \item Extract or validate symbol identifiers for each observation
#'   \item Verify all symbols exist in the trained models
#'   \item Route each observation to its symbol-specific \code{\link{qbm}} model
#'   \item Combine predictions maintaining original row order
#' }
#'
#' Symbols in \code{newdata} must match those used during training. Unknown
#' symbols will trigger an error with a list of available symbols.
#'
#' @seealso \code{\link{mqbm}}, \code{\link{predict.qbm}}, \code{\link{fitted.mqbm}},
#'   \code{\link{residuals.mqbm}}
#'
#' @examples
#' \dontrun{
#' # Train multi-symbol model
#' df <- data.frame(
#'   x1 = rnorm(200),
#'   x2 = rnorm(200),
#'   symbol = sample(c("A", "B", "C"), 200, replace = TRUE)
#' )
#' df$y <- df$x1 * 0.5 + rnorm(200)
#' fit <- mqbm(y ~ x1 + x2, data = df, tau = 0.5, nrounds = 50)
#'
#' # Method 1: Symbol in newdata
#' newdata_with_symbol <- data.frame(
#'   x1 = c(0, 1, -1),
#'   x2 = c(0, 0, 1),
#'   symbol = c("A", "B", "A")
#' )
#' predict(fit, newdata_with_symbol)
#'
#' # Method 2: Symbol as separate argument
#' newdata_no_symbol <- data.frame(
#'   x1 = c(0, 1, -1),
#'   x2 = c(0, 0, 1)
#' )
#' symbols <- c("A", "B", "C")
#' predict(fit, newdata_no_symbol, symbol = symbols)
#'
#' # Predictions automatically use correct symbol-specific model
#' # Each row gets prediction from its designated symbol model
#' }
#'
#' @export
#' @method predict mqbm
predict.mqbm <- function(object, newdata, symbol = NULL, ...) {
  if (!inherits(object, "mqbm")) {
    stop("`object` must be a mqbm model.", call. = FALSE)
  }
  if (missing(newdata)) {
    stop("`newdata` is required for prediction.", call. = FALSE)
  }

  # Extract symbol from newdata or use provided symbol argument
  if (is.null(symbol)) {
    if (is.data.frame(newdata) && "symbol" %in% names(newdata)) {
      symbol <- as.character(newdata$symbol)
      # Remove symbol from newdata for prediction
      newdata_for_pred <- newdata[, names(newdata) != "symbol", drop = FALSE]
    } else {
      stop("`symbol` must be provided either as a column in `newdata` or as a separate argument.", call. = FALSE)
    }
  } else {
    symbol <- as.character(symbol)
    newdata_for_pred <- newdata
  }

  # Validate symbol length
  n_rows <- if (is.data.frame(newdata_for_pred) || is.matrix(newdata_for_pred)) {
    nrow(newdata_for_pred)
  } else {
    length(newdata_for_pred)
  }
  
  if (length(symbol) != n_rows) {
    stop("`symbol` length must match the number of rows in `newdata`.", call. = FALSE)
  }

  # Check for unknown symbols
  unknown_symbols <- setdiff(unique(symbol), object$symbols)
  if (length(unknown_symbols) > 0) {
    stop("Unknown symbols in prediction data: ", paste(unknown_symbols, collapse = ", "), 
         "\nAvailable symbols: ", paste(object$symbols, collapse = ", "), call. = FALSE)
  }

  # Process newdata according to preprocess type
  if (!is.null(object$preprocess) && identical(object$preprocess$type, "formula")) {
    terms_obj <- object$preprocess$terms
    if (is.null(terms_obj)) {
      stop("Terms information missing; cannot build design matrix for prediction.", call. = FALSE)
    }
    terms_noy <- stats::delete.response(terms_obj)
    nd <- newdata_for_pred
    if (!is.data.frame(nd)) {
      nd <- as.data.frame(nd)
    }
    mf <- stats::model.frame(
      terms_noy,
      nd,
      na.action = stats::na.pass,
      xlev = object$preprocess$xlevels
    )
    newdata_matrix <- stats::model.matrix(
      terms_noy,
      mf,
      contrasts.arg = object$preprocess$contrasts
    )
    # Remove intercept column if present (consistent with training)
    if ("(Intercept)" %in% colnames(newdata_matrix)) {
      newdata_matrix <- newdata_matrix[, colnames(newdata_matrix) != "(Intercept)", drop = FALSE]
    }
  } else if (!is.matrix(newdata_for_pred)) {
    newdata_matrix <- data.matrix(newdata_for_pred)
  } else {
    newdata_matrix <- newdata_for_pred
  }

  # Ensure plain numeric matrix
  if (is.matrix(newdata_matrix)) {
    feature_names <- colnames(newdata_matrix)
    newdata_matrix <- matrix(as.numeric(newdata_matrix),
                             nrow = nrow(newdata_matrix),
                             ncol = ncol(newdata_matrix))
    colnames(newdata_matrix) <- feature_names
  }

  # Initialize predictions vector
  predictions <- numeric(length(symbol))
  
  # Predict for each symbol using its corresponding model
  for (sym in object$symbols) {
    idx <- which(symbol == sym)
    if (length(idx) > 0) {
      x_sym <- newdata_matrix[idx, , drop = FALSE]
      predictions[idx] <- predict(object$models[[sym]], x_sym, ...)
    }
  }

  predictions
}
