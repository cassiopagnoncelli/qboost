% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mqbm.R
\name{mqbm}
\alias{mqbm}
\title{Fit multiplexed (multi-group) quantile regression models}
\usage{
mqbm(
  ...,
  multiplexer,
  tau = 0.5,
  nrounds = 500,
  nfolds = 5,
  params = list(),
  early_stopping_rounds = 50,
  seed = 1,
  train_idx = NULL,
  val_idx = NULL,
  folds = NULL
)
}
\arguments{
\item{...}{Either a formula with \code{data} argument (where \code{data} must
contain a column specified by \code{multiplexer} identifying groups), or an \code{x}/\code{y}/\code{multiplexer}
triplet for matrix input. Additional arguments are forwarded to \code{\link{qbm}}.}

\item{multiplexer}{Character string specifying the column name in \code{data} (for formula interface)
or the name of the grouping variable to use as a multiplexer. Required parameter.}

\item{tau}{Target quantile level in (0, 1] applied to all group-specific models.
Default is 0.5 (median).}

\item{nrounds}{Maximum number of boosting iterations per group model. Default is 500.}

\item{nfolds}{Number of cross-validation folds for each group model. Default is 5.}

\item{params}{Optional named list of LightGBM parameters shared across all
group-specific models. See \code{\link{qbm}} for available parameters.}

\item{early_stopping_rounds}{Early stopping patience for each group model. Default is 50.}

\item{seed}{Random seed for reproducibility across all group models. Default is 1.}

\item{train_idx}{Optional integer vector of training indices (referring to full dataset rows).
If provided with \code{val_idx}, performs single holdout validation for each group.
Indices are automatically subset per group respecting group boundaries.
Ignored if \code{folds} is specified.}

\item{val_idx}{Optional integer vector of validation indices (referring to full dataset rows).
Must be provided together with \code{train_idx}. Ignored if \code{folds} is specified.}

\item{folds}{Optional list of integer vectors specifying custom fold structure for CV
(referring to full dataset rows). Each element should contain validation indices for that fold.
Takes priority over \code{train_idx}/\code{val_idx}. Indices are automatically subset per group.}
}
\value{
An object of class \code{mqbm} containing:
\item{models}{Named list of fitted \code{\link{qbm}} objects, one per group}
\item{multiplexer_values}{Character vector of unique group identifiers}
\item{multiplexer_info}{List with sample size and indices for each group}
\item{ecdf_funs}{Named list of ECDF functions, one per group, built from training y values}
\item{tau}{The target quantile level used}
\item{multiplexer}{Column name used for grouping}
\item{preprocess}{Preprocessing information (for formula interface)}
\item{timings}{Training time information}
\item{data_info}{Dataset dimensions (n, p, n_multiplexer)}
\item{training}{Training data (y and multiplexer vectors)}
}
\description{
Trains separate \code{\link{qbm}} quantile regression models for each group
in the data. This multiplexer enables heterogeneous
quantile modeling where different subgroups can have distinct relationships
between predictors and outcomes. Particularly useful for multi-asset portfolios,
multi-site studies, or any scenario where group-specific quantile behavior differs.
}
\details{
The mqbm (multiplexed qbm) approach:
\enumerate{
\item Partitions data by group
\item Trains independent \code{\link{qbm}} models for each group
\item Builds group-specific ECDF functions from training y values
\item Maintains separate hyperparameters and feature importance per group
\item Routes predictions to appropriate group-specific model
\item Transforms predictions through group-specific ECDF to return probabilities
}

This is beneficial when:
\itemize{
\item Different groups have heterogeneous quantile behavior
\item Sample sizes per group are sufficient for separate modeling
\item Group-specific feature importance is of interest
\item Interactions between predictors vary by group
}
}
\examples{
\dontrun{
# Multi-group financial data
set.seed(1)
df <- data.frame(
  x1 = rnorm(300),
  x2 = rnorm(300),
  cluster = sample(c("AAPL", "GOOGL", "MSFT"), 300, replace = TRUE)
)
# Different groups have different relationships
df$y <- ifelse(df$cluster == "AAPL",
  df$x1 * 2 + rnorm(300),
  df$x1 * 0.5 + df$x2 * 1.5 + rnorm(300)
)

# Formula interface - data must contain multiplexer column
fit <- mqbm(y ~ x1 + x2, data = df, multiplexer = "cluster", tau = 0.5, nrounds = 100)
print(fit)

# Predictions automatically route to correct group model
newdata <- data.frame(
  x1 = c(1, 1, 1),
  x2 = c(0, 0, 0),
  cluster = c("AAPL", "GOOGL", "MSFT")
)
predict(fit, newdata)

# Matrix interface
X <- as.matrix(df[, c("x1", "x2")])
fit2 <- mqbm(x = X, y = df$y, multiplexer = df$cluster, tau = 0.75)

# Access group-specific models
fit$models$AAPL # qbm model for AAPL
coef(fit) # Feature importance per group

# Different quantiles per group
fit_lower <- mqbm(y ~ x1 + x2, data = df, multiplexer = "cluster", tau = 0.1)
fit_upper <- mqbm(y ~ x1 + x2, data = df, multiplexer = "cluster", tau = 0.9)
}
}
\seealso{
\code{\link{qbm}}, \code{\link{predict.mqbm}}, \code{\link{fitted.mqbm}},
\code{\link{residuals.mqbm}}, \code{\link{coef.mqbm}}
}
